/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthzDetails,
  AuthzDetails$inboundSchema,
  AuthzDetails$Outbound,
  AuthzDetails$outboundSchema,
} from "./authzdetails.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Property,
  Property$inboundSchema,
  Property$Outbound,
  Property$outboundSchema,
} from "./property.js";

export type AuthorizationIssueRequest = {
  /**
   * The ticket issued from Authlete `/auth/authorization` API.
   *
   * @remarks
   */
  ticket: string;
  /**
   * The subject (= a user account managed by the service) who has granted authorization to the client application.
   *
   * @remarks
   */
  subject: string;
  /**
   * The time when the authentication of the end-user occurred. Its value is the number of seconds from `1970-01-01`.
   *
   * @remarks
   */
  authTime?: number | undefined;
  /**
   * The Authentication Context Class Reference performed for the end-user authentication.
   */
  acr?: string | undefined;
  /**
   * The claims of the end-user (= pieces of information about the end-user) in JSON format.
   *
   * @remarks
   * See [OpenID Connect Core 1.0, 5.1. Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) for details about the format.
   */
  claims?: string | undefined;
  /**
   * Extra properties to associate with an access token and/or an authorization code.
   */
  properties?: Array<Property> | undefined;
  /**
   * Scopes to associate with an access token and/or an authorization code.
   *
   * @remarks
   * If a non-empty string array is given, it replaces the scopes specified by the original authorization request.
   */
  scopes?: Array<string> | undefined;
  /**
   * The value of the `sub` claim to embed in an ID token. If this request parameter is `null` or empty,
   *
   * @remarks
   * the value of the `subject` request parameter is used as the value of the `sub` claim.
   */
  sub?: string | undefined;
  /**
   * JSON that represents additional JWS header parameters for ID tokens that may be issued based on
   *
   * @remarks
   * the authorization request.
   */
  idtHeaderParams?: string | undefined;
  /**
   * Claim key-value pairs that are used to compute transformed claims.
   *
   * @remarks
   */
  claimsForTx?: string | undefined;
  /**
   * the claims that the user has consented for the client application
   *
   * @remarks
   * to know.
   */
  consentedClaims?: Array<string> | undefined;
  /**
   * The authorization details. This represents the value of the `authorization_details`
   *
   * @remarks
   * request parameter in the preceding device authorization request which is defined in
   * "OAuth 2.0 Rich Authorization Requests".
   */
  authorizationDetails?: AuthzDetails | undefined;
  /**
   * Additional claims that are added to the payload part of the JWT access token.
   *
   * @remarks
   */
  jwtAtClaims?: string | undefined;
  /**
   * The representation of an access token that may be issued as a result of the Authlete API call.
   *
   * @remarks
   */
  accessToken?: string | undefined;
  /**
   * The duration (in seconds) of the access token that may be issued as a result of the Authlete
   *
   * @remarks
   * API call.
   *
   * When this request parameter holds a positive integer, it is used as the duration of the access
   * token in. In other cases, this request parameter is ignored.
   */
  accessTokenDuration?: number | undefined;
  /**
   * The session ID of the user's authentication session. The specified value will be embedded in the
   *
   * @remarks
   * ID token as the value of the `sid` claim. This parameter needs to be provided only if you want
   * to support the [OpenID Connect Native SSO for Mobile Apps 1.0](https://openid.net/specs/openid-connect-native-sso-1_0.html)
   * specification (a.k.a. "Native SSO"). To enable support for the Native SSO specification, the
   * `nativeSsoSupported` property of your service must be set to `true`.
   *
   * NOTE: When the response from the `/auth/authorization` API contains the `nativeSsoRequested`
   * property with a value of `true`, the `sessionId` request parameter must be provided to the
   * `/auth/authorization/issue` API.
   */
  sessionId?: string | undefined;
  /**
   * The type of the `aud` claim of the ID token being issued. Valid values are as follows.
   *
   * @remarks
   *
   * | Value | Description |
   * | ----- | ----------- |
   * | "array" | The type of the aud claim is always an array of strings. |
   * | "string" | The type of the aud claim is always a single string. |
   * | null | The type of the aud claim remains the same as before. |
   *
   * This request parameter takes precedence over the `idTokenAudType` property of the service.
   */
  idTokenAudType?: string | undefined;
  /**
   * Values of verified claims requested indirectly by "transformed claims".
   *
   * @remarks
   *
   * A client application may request "transformed claims". Each of transformed claims uses an existing
   * claim as input. As a result, to compute the value of a transformed claim, the value of the referenced
   * existing claim is needed. This `verifiedClaimsForTx` request parameter has to be used to provide
   * values of existing claims for computation of transformed claims.
   *
   * A response from the `/auth/authorization` API may include the `requestedVerifiedClaimsForTx` response
   * parameter which is a list of verified claims that are referenced indirectly by transformed claims
   * (cf. `requestedVerifiedClaimsForTx` in `/auth/authorization` API response). The authorization
   * server implementation should prepare values of the verified claims listed in `requestedVerifiedClaimsForTx`
   * and pass them as the value of this `verifiedClaimsForTx` request parameter.
   *
   * The following is an example of the value of this request parameter.
   *
   * ```
   * [
   *   "{\"birthdate\":\"1970-01-23\",\"nationalities\":[\"DEU\",\"USA\"]}"
   * ]
   * ```
   *
   * The reason that this `verifiedClaimsForTx` property is an array is that the `"verified_claims"`
   * property in the claims request parameter of an authorization request can be an array like below.
   *
   * ```
   * {
   *   "transformed_claims": {
   *     "nationality_usa": {
   *       "claim": "nationalities",
   *       "fn": [
   *         [ "eq", "USA" ],
   *         "any"
   *       ]
   *     }
   *   },
   *   "id_token": {
   *     "verified_claims": [
   *       {
   *         "verification": { "trust_framework": { "value": "gold" } },
   *         "claims": { "::18_or_above": null }
   *       },
   *       {
   *         "verification": { "trust_framework": { "value": "silver" } },
   *         "claims": { ":nationality_usa": null }
   *       }
   *     ]
   *   }
   * }
   * ```
   *
   * For the example above, the value of this `verifiedClaimsForTx` property should be an array of
   * size 2 and look like below. The first element is JSON including claims which have been verified
   * under the trust framework `"gold"`, and the second element is JSON including claims which have
   * been verified under the trust framework `"silver"`.
   *
   * ```
   * [
   *   "{\"birthdate\":\"1970-01-23\"}",
   *   "{\"nationalities\":[\"DEU\",\"USA\"]}"
   * ]
   * ```
   */
  verifiedClaimsForTx?: string | undefined;
};

/** @internal */
export const AuthorizationIssueRequest$inboundSchema: z.ZodType<
  AuthorizationIssueRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  ticket: z.string(),
  subject: z.string(),
  authTime: z.number().int().optional(),
  acr: z.string().optional(),
  claims: z.string().optional(),
  properties: z.array(Property$inboundSchema).optional(),
  scopes: z.array(z.string()).optional(),
  sub: z.string().optional(),
  idtHeaderParams: z.string().optional(),
  claimsForTx: z.string().optional(),
  consentedClaims: z.array(z.string()).optional(),
  authorizationDetails: AuthzDetails$inboundSchema.optional(),
  jwtAtClaims: z.string().optional(),
  accessToken: z.string().optional(),
  accessTokenDuration: z.number().int().optional(),
  sessionId: z.string().optional(),
  idTokenAudType: z.string().optional(),
  verifiedClaimsForTx: z.string().optional(),
});

/** @internal */
export type AuthorizationIssueRequest$Outbound = {
  ticket: string;
  subject: string;
  authTime?: number | undefined;
  acr?: string | undefined;
  claims?: string | undefined;
  properties?: Array<Property$Outbound> | undefined;
  scopes?: Array<string> | undefined;
  sub?: string | undefined;
  idtHeaderParams?: string | undefined;
  claimsForTx?: string | undefined;
  consentedClaims?: Array<string> | undefined;
  authorizationDetails?: AuthzDetails$Outbound | undefined;
  jwtAtClaims?: string | undefined;
  accessToken?: string | undefined;
  accessTokenDuration?: number | undefined;
  sessionId?: string | undefined;
  idTokenAudType?: string | undefined;
  verifiedClaimsForTx?: string | undefined;
};

/** @internal */
export const AuthorizationIssueRequest$outboundSchema: z.ZodType<
  AuthorizationIssueRequest$Outbound,
  z.ZodTypeDef,
  AuthorizationIssueRequest
> = z.object({
  ticket: z.string(),
  subject: z.string(),
  authTime: z.number().int().optional(),
  acr: z.string().optional(),
  claims: z.string().optional(),
  properties: z.array(Property$outboundSchema).optional(),
  scopes: z.array(z.string()).optional(),
  sub: z.string().optional(),
  idtHeaderParams: z.string().optional(),
  claimsForTx: z.string().optional(),
  consentedClaims: z.array(z.string()).optional(),
  authorizationDetails: AuthzDetails$outboundSchema.optional(),
  jwtAtClaims: z.string().optional(),
  accessToken: z.string().optional(),
  accessTokenDuration: z.number().int().optional(),
  sessionId: z.string().optional(),
  idTokenAudType: z.string().optional(),
  verifiedClaimsForTx: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthorizationIssueRequest$ {
  /** @deprecated use `AuthorizationIssueRequest$inboundSchema` instead. */
  export const inboundSchema = AuthorizationIssueRequest$inboundSchema;
  /** @deprecated use `AuthorizationIssueRequest$outboundSchema` instead. */
  export const outboundSchema = AuthorizationIssueRequest$outboundSchema;
  /** @deprecated use `AuthorizationIssueRequest$Outbound` instead. */
  export type Outbound = AuthorizationIssueRequest$Outbound;
}

export function authorizationIssueRequestToJSON(
  authorizationIssueRequest: AuthorizationIssueRequest,
): string {
  return JSON.stringify(
    AuthorizationIssueRequest$outboundSchema.parse(authorizationIssueRequest),
  );
}

export function authorizationIssueRequestFromJSON(
  jsonString: string,
): SafeParseResult<AuthorizationIssueRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthorizationIssueRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthorizationIssueRequest' from JSON`,
  );
}
