/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type ClientExtension = {
  /**
   * The set of scopes that the client application is allowed to request. This paramter will be one
   *
   * @remarks
   * of the following.
   *
   *   - `null`
   *   - an empty set
   *   - a set with at least one element
   *
   * When the value of this parameter is `null`, it means that the set of scopes that the client
   * application is allowed to request is the set of the scopes that the service supports. When the
   * value of this parameter is an empty set, it means that the client application is not allowed to
   * request any scopes. When the value of this parameter is a set with at least one element, it means
   * that the set is the set of scopes that the client application is allowed to request.
   */
  requestableScopes?: Array<string> | undefined;
  /**
   * The flag to indicate whether "Requestable Scopes per Client" is enabled or not. If `true`, you
   *
   * @remarks
   * can define the set of scopes which this client application can request. If `false`, this client
   * application can request any scope which is supported by the authorization server.
   */
  requestableScopesEnabled?: boolean | undefined;
  /**
   * The value of the duration of access tokens per client in seconds. In normal cases, the value of
   *
   * @remarks
   * the service's `accessTokenDuration` property is used as the duration of access tokens issued by
   * the service. However, if this `accessTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of access tokens issued to the client application.
   *
   * Note that the duration of access tokens can be controlled by the scope attribute `access_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  accessTokenDuration?: number | undefined;
  /**
   * The value of the duration of refresh tokens per client in seconds. In normal cases, the value
   *
   * @remarks
   * of the service's `refreshTokenDuration` property is used as the duration of refresh tokens issued
   * by the service. However, if this `refreshTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of refresh tokens issued to the client application.
   *
   * Note that the duration of refresh tokens can be controlled by the scope attribute `refresh_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * The value of the duration of ID tokens per client in seconds. In normal cases, the value
   *
   * @remarks
   * of the service's `idTokenDuration` property is used as the duration of ID tokens issued
   * by the service. However, if this `idTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of ID tokens issued to the client application.
   *
   * Note that the duration of refresh tokens can be controlled by the scope attribute `id_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  idTokenDuration?: number | undefined;
  /**
   * Get the flag indicating whether the client is explicitly given a
   *
   * @remarks
   * permission to make token exchange requests ([RFC 8693][https://www.rfc-editor.org/rfc/rfc8693.html])
   */
  tokenExchangePermitted?: boolean | undefined;
};

/** @internal */
export const ClientExtension$inboundSchema: z.ZodType<
  ClientExtension,
  z.ZodTypeDef,
  unknown
> = z.object({
  requestableScopes: z.array(z.string()).optional(),
  requestableScopesEnabled: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idTokenDuration: z.number().int().optional(),
  tokenExchangePermitted: z.boolean().optional(),
});

/** @internal */
export type ClientExtension$Outbound = {
  requestableScopes?: Array<string> | undefined;
  requestableScopesEnabled?: boolean | undefined;
  accessTokenDuration?: number | undefined;
  refreshTokenDuration?: number | undefined;
  idTokenDuration?: number | undefined;
  tokenExchangePermitted?: boolean | undefined;
};

/** @internal */
export const ClientExtension$outboundSchema: z.ZodType<
  ClientExtension$Outbound,
  z.ZodTypeDef,
  ClientExtension
> = z.object({
  requestableScopes: z.array(z.string()).optional(),
  requestableScopesEnabled: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idTokenDuration: z.number().int().optional(),
  tokenExchangePermitted: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientExtension$ {
  /** @deprecated use `ClientExtension$inboundSchema` instead. */
  export const inboundSchema = ClientExtension$inboundSchema;
  /** @deprecated use `ClientExtension$outboundSchema` instead. */
  export const outboundSchema = ClientExtension$outboundSchema;
  /** @deprecated use `ClientExtension$Outbound` instead. */
  export type Outbound = ClientExtension$Outbound;
}

export function clientExtensionToJSON(
  clientExtension: ClientExtension,
): string {
  return JSON.stringify(ClientExtension$outboundSchema.parse(clientExtension));
}

export function clientExtensionFromJSON(
  jsonString: string,
): SafeParseResult<ClientExtension, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientExtension$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientExtension' from JSON`,
  );
}
