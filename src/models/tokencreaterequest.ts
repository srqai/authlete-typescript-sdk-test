/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthzDetails,
  AuthzDetails$inboundSchema,
  AuthzDetails$Outbound,
  AuthzDetails$outboundSchema,
} from "./authzdetails.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  GrantType,
  GrantType$inboundSchema,
  GrantType$outboundSchema,
} from "./granttype.js";
import {
  Property,
  Property$inboundSchema,
  Property$Outbound,
  Property$outboundSchema,
} from "./property.js";

export type TokenCreateRequest = {
  /**
   * The grant type of the access token when the access token was created.
   *
   * @remarks
   */
  grantType: GrantType;
  /**
   * The ID of the client application which will be associated with a newly created access token.
   *
   * @remarks
   */
  clientId: number;
  /**
   * The subject (= unique identifier) of the user who will be associated with a newly created access
   *
   * @remarks
   * token. This parameter is required unless the grant type is `CLIENT_CREDENTIALS`. The value must
   * consist of only ASCII characters and its length must not exceed 100.
   */
  subject?: string | undefined;
  /**
   * The scopes which will be associated with a newly created access token. Scopes that are not supported
   *
   * @remarks
   * by the service cannot be specified and requesting them will cause an error.
   */
  scopes?: Array<string> | undefined;
  /**
   * The duration of a newly created access token in seconds. If the value is 0, the duration is determined
   *
   * @remarks
   * according to the settings of the service.
   */
  accessTokenDuration?: number | undefined;
  /**
   * The duration of a newly created refresh token in seconds. If the value is 0, the duration is
   *
   * @remarks
   * determined according to the settings of the service.
   *
   * A refresh token is not created (1) if the service does not support `REFRESH_TOKEN`, or (2) if the
   * specified grant type is either `IMPLICIT`or `CLIENT_CREDENTIALS`.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * Extra properties to associate with a newly created access token. Note that properties parameter
   *
   * @remarks
   * is accepted only when the HTTP method of the request is POST and Content-Type of the request is
   * `application/json`, so don't use `GET` method or `application/x-www-form-urlencoded` if you want
   * to specify properties.
   */
  properties?: Array<Property> | undefined;
  /**
   * A boolean request parameter which indicates whether to emulate that the client ID alias is used
   *
   * @remarks
   * instead of the original numeric client ID when a new access token is created.
   *
   * This has an effect only on the value of the aud claim in a response from [UserInfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).
   * When you access the UserInfo endpoint (which is expected to be implemented using Authlete's
   * `/api/auth/userinfo` API and `/api/auth/userinfo/issue` API) with an access token which has been
   * created using Authlete's `/api/auth/token/create` API with this property (`clientIdAliasUsed`)
   * `true`, the client ID alias is used as the value of the aud claim in a response from the UserInfo
   * endpoint.
   *
   * Note that if a client ID alias is not assigned to the client when Authlete's `/api/auth/token/create`
   * API is called, this property (`clientIdAliasUsed`) has no effect (it is always regarded as `false`).
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The value of the new access token.
   *
   * @remarks
   *
   * The `/api/auth/token/create` API generates an access token. Therefore, callers of the API do not
   * have to specify values of newly created access tokens. However, in some cases, for example, if
   * you want to migrate existing access tokens from an old system to Authlete, you may want to specify
   * values of access tokens. In such a case, you can specify the value of a newly created access token
   * by passing a non-null value as the value of accessToken request parameter. The implementation
   * of the `/api/auth/token/create` uses the value of the accessToken request parameter instead of
   * generating a new value when the request parameter holds a non-null value.
   *
   * Note that if the hash value of the specified access token already exists in Authlete's database,
   * the access token cannot be inserted and the `/api/auth/token/create` API will report an error.
   */
  accessToken?: string | undefined;
  /**
   * The value of the new refresh token.
   *
   * @remarks
   *
   * The `/api/auth/token/create` API may generate a refresh token. Therefore, callers of the API do
   * not have to specify values of newly created refresh tokens. However, in some cases, for example,
   * if you want to migrate existing refresh tokens from an old system to Authlete, you may want to
   * specify values of refresh tokens. In such a case, you can specify the value of a newly created
   * refresh token by passing a non-null value as the value of refreshToken request parameter. The
   * implementation of the `/api/auth/token/create` uses the value of the refreshToken request parameter
   * instead of generating a new value when the request parameter holds a non-null value.
   *
   * Note that if the hash value of the specified refresh token already exists in Authlete's database,
   * the refresh token cannot be inserted and the `/api/auth/token/create` API will report an error.
   */
  refreshToken?: string | undefined;
  /**
   * Get whether the access token expires or not. By default, all access tokens expire after a period
   *
   * @remarks
   * of time determined by their service.
   *
   * If this request parameter is `true`, then the access token will not automatically expire and must
   * be revoked or deleted manually at the service. If this request parameter is true, the `accessTokenDuration`
   * request parameter is ignored.
   */
  accessTokenPersistent?: boolean | undefined;
  /**
   * The thumbprint of the MTLS certificate bound to this token. If this property is set, a certificate
   *
   * @remarks
   * with the corresponding value MUST be presented with the access token when it is used by a client.
   * The value of this property must be a SHA256 certificate thumbprint, base64url encoded.
   */
  certificateThumbprint?: string | undefined;
  /**
   * The thumbprint of the public key used for DPoP presentation of this token. If this property is
   *
   * @remarks
   * set, a DPoP proof signed with the corresponding private key MUST be presented with the access
   * token when it is used by a client. Additionally, the token's `token_type` will be set to 'DPoP'.
   */
  dpopKeyThumbprint?: string | undefined;
  /**
   * The authorization details. This represents the value of the `authorization_details`
   *
   * @remarks
   * request parameter in the preceding device authorization request which is defined in
   * "OAuth 2.0 Rich Authorization Requests".
   */
  authorizationDetails?: AuthzDetails | undefined;
  /**
   * The value of the resources to associate with the token. This property represents the value of
   *
   * @remarks
   * one or more `resource` request parameters which is defined in "RFC8707 Resource Indicators for
   * OAuth 2.0".
   */
  resources?: Array<string> | undefined;
  /**
   * the flag which indicates whether the access token is for an external
   *
   * @remarks
   * attachment.
   */
  forExternalAttachment?: boolean | undefined;
  /**
   * Additional claims that are added to the payload part of the JWT access token.
   *
   * @remarks
   */
  jwtAtClaims?: string | undefined;
  /**
   * The Authentication Context Class Reference of the user authentication that the authorization server performed
   *
   * @remarks
   * during the course of issuing the access token.
   */
  acr?: string | undefined;
  /**
   * The time when the user authentication was performed during the course of issuing the access token.
   *
   * @remarks
   */
  authTime?: number | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
  /**
   * The client Identifier associated with the newly issued access token.
   *
   * @remarks
   */
  clientIdentifier?: string | undefined;
  /**
   * The session ID, which is the ID of the user's authentication session, associated with a newly
   *
   * @remarks
   * created access token.
   */
  sessionId?: string | undefined;
};

/** @internal */
export const TokenCreateRequest$inboundSchema: z.ZodType<
  TokenCreateRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  grantType: GrantType$inboundSchema,
  clientId: z.number().int(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  properties: z.array(Property$inboundSchema).optional(),
  clientIdAliasUsed: z.boolean().optional(),
  accessToken: z.string().optional(),
  refreshToken: z.string().optional(),
  accessTokenPersistent: z.boolean().optional(),
  certificateThumbprint: z.string().optional(),
  dpopKeyThumbprint: z.string().optional(),
  authorizationDetails: AuthzDetails$inboundSchema.optional(),
  resources: z.array(z.string()).optional(),
  forExternalAttachment: z.boolean().optional(),
  jwtAtClaims: z.string().optional(),
  acr: z.string().optional(),
  authTime: z.number().int().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  clientIdentifier: z.string().optional(),
  sessionId: z.string().optional(),
});

/** @internal */
export type TokenCreateRequest$Outbound = {
  grantType: string;
  clientId: number;
  subject?: string | undefined;
  scopes?: Array<string> | undefined;
  accessTokenDuration?: number | undefined;
  refreshTokenDuration?: number | undefined;
  properties?: Array<Property$Outbound> | undefined;
  clientIdAliasUsed?: boolean | undefined;
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  accessTokenPersistent?: boolean | undefined;
  certificateThumbprint?: string | undefined;
  dpopKeyThumbprint?: string | undefined;
  authorizationDetails?: AuthzDetails$Outbound | undefined;
  resources?: Array<string> | undefined;
  forExternalAttachment?: boolean | undefined;
  jwtAtClaims?: string | undefined;
  acr?: string | undefined;
  authTime?: number | undefined;
  clientEntityIdUsed?: boolean | undefined;
  clientIdentifier?: string | undefined;
  sessionId?: string | undefined;
};

/** @internal */
export const TokenCreateRequest$outboundSchema: z.ZodType<
  TokenCreateRequest$Outbound,
  z.ZodTypeDef,
  TokenCreateRequest
> = z.object({
  grantType: GrantType$outboundSchema,
  clientId: z.number().int(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  properties: z.array(Property$outboundSchema).optional(),
  clientIdAliasUsed: z.boolean().optional(),
  accessToken: z.string().optional(),
  refreshToken: z.string().optional(),
  accessTokenPersistent: z.boolean().optional(),
  certificateThumbprint: z.string().optional(),
  dpopKeyThumbprint: z.string().optional(),
  authorizationDetails: AuthzDetails$outboundSchema.optional(),
  resources: z.array(z.string()).optional(),
  forExternalAttachment: z.boolean().optional(),
  jwtAtClaims: z.string().optional(),
  acr: z.string().optional(),
  authTime: z.number().int().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  clientIdentifier: z.string().optional(),
  sessionId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TokenCreateRequest$ {
  /** @deprecated use `TokenCreateRequest$inboundSchema` instead. */
  export const inboundSchema = TokenCreateRequest$inboundSchema;
  /** @deprecated use `TokenCreateRequest$outboundSchema` instead. */
  export const outboundSchema = TokenCreateRequest$outboundSchema;
  /** @deprecated use `TokenCreateRequest$Outbound` instead. */
  export type Outbound = TokenCreateRequest$Outbound;
}

export function tokenCreateRequestToJSON(
  tokenCreateRequest: TokenCreateRequest,
): string {
  return JSON.stringify(
    TokenCreateRequest$outboundSchema.parse(tokenCreateRequest),
  );
}

export function tokenCreateRequestFromJSON(
  jsonString: string,
): SafeParseResult<TokenCreateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TokenCreateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TokenCreateRequest' from JSON`,
  );
}
