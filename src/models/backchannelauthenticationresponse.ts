/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthzDetails,
  AuthzDetails$inboundSchema,
  AuthzDetails$Outbound,
  AuthzDetails$outboundSchema,
} from "./authzdetails.js";
import {
  DeliveryMode,
  DeliveryMode$inboundSchema,
  DeliveryMode$outboundSchema,
} from "./deliverymode.js";
import {
  DynamicScope,
  DynamicScope$inboundSchema,
  DynamicScope$Outbound,
  DynamicScope$outboundSchema,
} from "./dynamicscope.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Grant,
  Grant$inboundSchema,
  Grant$Outbound,
  Grant$outboundSchema,
} from "./grant.js";
import {
  GrantManagementAction,
  GrantManagementAction$inboundSchema,
  GrantManagementAction$outboundSchema,
} from "./grantmanagementaction.js";
import {
  Pair,
  Pair$inboundSchema,
  Pair$Outbound,
  Pair$outboundSchema,
} from "./pair.js";
import {
  Scope,
  Scope$inboundSchema,
  Scope$Outbound,
  Scope$outboundSchema,
} from "./scope.js";

/**
 * The next action that the authorization server implementation should take.
 */
export const BackchannelAuthenticationResponseAction = {
  InternalServerError: "INTERNAL_SERVER_ERROR",
  BadRequest: "BAD_REQUEST",
  Unauthorized: "UNAUTHORIZED",
  UserIdentification: "USER_IDENTIFICATION",
} as const;
/**
 * The next action that the authorization server implementation should take.
 */
export type BackchannelAuthenticationResponseAction = ClosedEnum<
  typeof BackchannelAuthenticationResponseAction
>;

export type BackchannelAuthenticationResponse = {
  /**
   * The code which represents the result of the API call.
   */
  resultCode?: string | undefined;
  /**
   * A short message which explains the result of the API call.
   */
  resultMessage?: string | undefined;
  /**
   * The next action that the authorization server implementation should take.
   */
  action?: BackchannelAuthenticationResponseAction | undefined;
  /**
   * The content that the authorization server implementation is to return to the client
   *
   * @remarks
   * application. Its format varies depending on the value of `action` parameter.
   */
  responseContent?: string | undefined;
  /**
   * The client ID of the client application that has made the backchannel authentication
   *
   * @remarks
   * request.
   */
  clientId?: number | undefined;
  /**
   * The client ID alias of the client application that has made the backchannel authentication
   *
   * @remarks
   * request.
   */
  clientIdAlias?: string | undefined;
  /**
   * `true` if the value of the client_id request parameter included in the backchannel
   *
   * @remarks
   * authentication request is the client ID alias. `false` if the value is the original
   * numeric client ID.
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The name of the client application which has made the backchannel authentication request.
   *
   * @remarks
   */
  clientName?: string | undefined;
  /**
   * The scopes requested by the backchannel authentication request.
   *
   * @remarks
   *
   * Basically, this property holds the value of the `scope` request parameter in the backchannel
   * authentication request. However, because unregistered scopes are dropped on Authlete side,
   * if the `scope` request parameter contains unknown scopes, the list returned by this
   * property becomes different from the value of the `scope` request parameter.
   *
   * Note that `description` property and `descriptions` property of each `scope` object
   * in the array contained in this property is always null even if descriptions of the scopes
   * are registered.
   */
  scopes?: Array<Scope> | undefined;
  /**
   * The names of the claims which were requested indirectly via some special scopes.
   *
   * @remarks
   * See [5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims)
   * in OpenID Connect Core 1.0 for details.
   */
  claimNames?: Array<string> | undefined;
  /**
   * The client notification token included in the backchannel authentication request.
   *
   * @remarks
   */
  clientNotificationToken?: string | undefined;
  /**
   * The list of ACR values requested by the backchannel authentication request.
   *
   * @remarks
   *
   * Basically, this property holds the value of the `acr_values` request parameter in the
   * backchannel authentication request. However, because unsupported ACR values are dropped
   * on Authlete side, if the `acr_values` request parameter contains unrecognized ACR values,
   * the list returned by this property becomes different from the value of the `acr_values`
   * request parameter.
   */
  acrs?: Array<string> | undefined;
  /**
   * The type of the hint for end-user identification which was included in the backchannel authentication request.
   *
   * @remarks
   */
  hintType?: string | undefined;
  /**
   * The value of the hint for end-user identification.
   *
   * @remarks
   */
  hint?: string | undefined;
  /**
   * The value of the `sub` claim contained in the ID token hint included in the backchannel authentication request.
   *
   * @remarks
   */
  sub?: string | undefined;
  /**
   * The binding message included in the backchannel authentication request.
   *
   * @remarks
   */
  bindingMessage?: string | undefined;
  /**
   * The binding message included in the backchannel authentication request.
   *
   * @remarks
   */
  userCode?: string | undefined;
  /**
   * The flag which indicates whether a user code is required.
   *
   * @remarks
   *
   * `true` when both the `backchannel_user_code_parameter` metadata of the client (= Client's
   * `bcUserCodeRequired` property) and the `backchannel_user_code_parameter_supported`
   * metadata of the service (= Service's `backchannelUserCodeParameterSupported` property)
   * are `true`.
   */
  userCodeRequired?: boolean | undefined;
  /**
   * The requested expiry for the authentication request ID (`auth_req_id`).
   *
   * @remarks
   */
  requestedExpiry?: number | undefined;
  /**
   * The request context of the backchannel authentication request.
   *
   * @remarks
   *
   * It is the value of the request_context claim in the signed authentication request and
   * its format is JSON. request_context is a new claim added by the FAPI-CIBA profile.
   */
  requestContext?: string | undefined;
  /**
   * The warnings raised during processing the backchannel authentication request.
   *
   * @remarks
   */
  warnings?: Array<string> | undefined;
  /**
   * The ticket which is necessary to call Authlete's `/auth/token/fail` API or `/auth/token/issue` API.
   *
   * @remarks
   *
   * This parameter has a value only if the value of `grant_type` request parameter is `password` and the token request is valid.
   */
  ticket?: string | undefined;
  /**
   * The resources specified by the `resource` request parameters or by the `resource` property
   *
   * @remarks
   * in the request object. If both are given, the values in the request object should be
   * set. See "Resource Indicators for OAuth 2.0" for details.
   */
  resources?: Array<string> | undefined;
  /**
   * The authorization details. This represents the value of the `authorization_details`
   *
   * @remarks
   * request parameter in the preceding device authorization request which is defined in
   * "OAuth 2.0 Rich Authorization Requests".
   */
  authorizationDetails?: AuthzDetails | undefined;
  /**
   * The attributes of this service that the client application belongs to.
   *
   * @remarks
   */
  serviceAttributes?: Array<Pair> | undefined;
  /**
   * The attributes of the client.
   *
   * @remarks
   */
  clientAttributes?: Array<Pair> | undefined;
  /**
   * The dynamic scopes which the client application requested by the scope request parameter.
   *
   * @remarks
   */
  dynamicScopes?: Array<DynamicScope> | undefined;
  deliveryMode?: DeliveryMode | undefined;
  /**
   * The client authentication method that was performed.
   *
   * @remarks
   */
  clientAuthMethod?: string | undefined;
  /**
   * The grant management action of the device authorization request.
   *
   * @remarks
   *
   * The `grant_management_action` request parameter is defined in
   * [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html).
   */
  gmAction?: GrantManagementAction | undefined;
  /**
   * the value of the `grant_id` request parameter of the device authorization request.
   *
   * @remarks
   *
   * The `grant_id` request parameter is defined in
   * [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html)
   * , which is supported by Authlete 2.3 and newer versions.
   */
  grantId?: string | undefined;
  grant?: Grant | undefined;
  /**
   * The subject identifying the user who has given the grant identified
   *
   * @remarks
   * by the `grant_id` request parameter of the device authorization
   * request.
   *
   * Authlete 2.3 and newer versions support <a href=
   * "https://openid.net/specs/fapi-grant-management.html">Grant Management
   * for OAuth 2.0</a>. An authorization request may contain a `grant_id`
   * request parameter which is defined in the specification. If the value of
   * the request parameter is valid, {@link #getGrantSubject()} will return
   * the subject of the user who has given the grant to the client application.
   * Authorization server implementations may use the value returned from
   * {@link #getGrantSubject()} in order to determine the user to authenticate.
   *
   * The user your system will authenticate during the authorization process
   * (or has already authenticated) may be different from the user of the
   * grant. The first implementer's draft of "Grant Management for OAuth 2.0"
   * does not mention anything about the case, so the behavior in the case is
   * left to implementations. Authlete will not perform the grant management
   * action when the `subject` passed to Authlete does not match the
   * user of the grant.
   */
  grantSubject?: string | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
};

/** @internal */
export const BackchannelAuthenticationResponseAction$inboundSchema:
  z.ZodNativeEnum<typeof BackchannelAuthenticationResponseAction> = z
    .nativeEnum(BackchannelAuthenticationResponseAction);

/** @internal */
export const BackchannelAuthenticationResponseAction$outboundSchema:
  z.ZodNativeEnum<typeof BackchannelAuthenticationResponseAction> =
    BackchannelAuthenticationResponseAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackchannelAuthenticationResponseAction$ {
  /** @deprecated use `BackchannelAuthenticationResponseAction$inboundSchema` instead. */
  export const inboundSchema =
    BackchannelAuthenticationResponseAction$inboundSchema;
  /** @deprecated use `BackchannelAuthenticationResponseAction$outboundSchema` instead. */
  export const outboundSchema =
    BackchannelAuthenticationResponseAction$outboundSchema;
}

/** @internal */
export const BackchannelAuthenticationResponse$inboundSchema: z.ZodType<
  BackchannelAuthenticationResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: BackchannelAuthenticationResponseAction$inboundSchema.optional(),
  responseContent: z.string().optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  clientName: z.string().optional(),
  scopes: z.array(Scope$inboundSchema).optional(),
  claimNames: z.array(z.string()).optional(),
  clientNotificationToken: z.string().optional(),
  acrs: z.array(z.string()).optional(),
  hintType: z.string().optional(),
  hint: z.string().optional(),
  sub: z.string().optional(),
  bindingMessage: z.string().optional(),
  userCode: z.string().optional(),
  userCodeRequired: z.boolean().optional(),
  requestedExpiry: z.number().int().optional(),
  requestContext: z.string().optional(),
  warnings: z.array(z.string()).optional(),
  ticket: z.string().optional(),
  resources: z.array(z.string()).optional(),
  authorizationDetails: AuthzDetails$inboundSchema.optional(),
  serviceAttributes: z.array(Pair$inboundSchema).optional(),
  clientAttributes: z.array(Pair$inboundSchema).optional(),
  dynamicScopes: z.array(DynamicScope$inboundSchema).optional(),
  deliveryMode: DeliveryMode$inboundSchema.optional(),
  clientAuthMethod: z.string().optional(),
  gmAction: GrantManagementAction$inboundSchema.optional(),
  grantId: z.string().optional(),
  grant: Grant$inboundSchema.optional(),
  grantSubject: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/** @internal */
export type BackchannelAuthenticationResponse$Outbound = {
  resultCode?: string | undefined;
  resultMessage?: string | undefined;
  action?: string | undefined;
  responseContent?: string | undefined;
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  clientName?: string | undefined;
  scopes?: Array<Scope$Outbound> | undefined;
  claimNames?: Array<string> | undefined;
  clientNotificationToken?: string | undefined;
  acrs?: Array<string> | undefined;
  hintType?: string | undefined;
  hint?: string | undefined;
  sub?: string | undefined;
  bindingMessage?: string | undefined;
  userCode?: string | undefined;
  userCodeRequired?: boolean | undefined;
  requestedExpiry?: number | undefined;
  requestContext?: string | undefined;
  warnings?: Array<string> | undefined;
  ticket?: string | undefined;
  resources?: Array<string> | undefined;
  authorizationDetails?: AuthzDetails$Outbound | undefined;
  serviceAttributes?: Array<Pair$Outbound> | undefined;
  clientAttributes?: Array<Pair$Outbound> | undefined;
  dynamicScopes?: Array<DynamicScope$Outbound> | undefined;
  deliveryMode?: string | undefined;
  clientAuthMethod?: string | undefined;
  gmAction?: string | undefined;
  grantId?: string | undefined;
  grant?: Grant$Outbound | undefined;
  grantSubject?: string | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
};

/** @internal */
export const BackchannelAuthenticationResponse$outboundSchema: z.ZodType<
  BackchannelAuthenticationResponse$Outbound,
  z.ZodTypeDef,
  BackchannelAuthenticationResponse
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: BackchannelAuthenticationResponseAction$outboundSchema.optional(),
  responseContent: z.string().optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  clientName: z.string().optional(),
  scopes: z.array(Scope$outboundSchema).optional(),
  claimNames: z.array(z.string()).optional(),
  clientNotificationToken: z.string().optional(),
  acrs: z.array(z.string()).optional(),
  hintType: z.string().optional(),
  hint: z.string().optional(),
  sub: z.string().optional(),
  bindingMessage: z.string().optional(),
  userCode: z.string().optional(),
  userCodeRequired: z.boolean().optional(),
  requestedExpiry: z.number().int().optional(),
  requestContext: z.string().optional(),
  warnings: z.array(z.string()).optional(),
  ticket: z.string().optional(),
  resources: z.array(z.string()).optional(),
  authorizationDetails: AuthzDetails$outboundSchema.optional(),
  serviceAttributes: z.array(Pair$outboundSchema).optional(),
  clientAttributes: z.array(Pair$outboundSchema).optional(),
  dynamicScopes: z.array(DynamicScope$outboundSchema).optional(),
  deliveryMode: DeliveryMode$outboundSchema.optional(),
  clientAuthMethod: z.string().optional(),
  gmAction: GrantManagementAction$outboundSchema.optional(),
  grantId: z.string().optional(),
  grant: Grant$outboundSchema.optional(),
  grantSubject: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackchannelAuthenticationResponse$ {
  /** @deprecated use `BackchannelAuthenticationResponse$inboundSchema` instead. */
  export const inboundSchema = BackchannelAuthenticationResponse$inboundSchema;
  /** @deprecated use `BackchannelAuthenticationResponse$outboundSchema` instead. */
  export const outboundSchema =
    BackchannelAuthenticationResponse$outboundSchema;
  /** @deprecated use `BackchannelAuthenticationResponse$Outbound` instead. */
  export type Outbound = BackchannelAuthenticationResponse$Outbound;
}

export function backchannelAuthenticationResponseToJSON(
  backchannelAuthenticationResponse: BackchannelAuthenticationResponse,
): string {
  return JSON.stringify(
    BackchannelAuthenticationResponse$outboundSchema.parse(
      backchannelAuthenticationResponse,
    ),
  );
}

export function backchannelAuthenticationResponseFromJSON(
  jsonString: string,
): SafeParseResult<BackchannelAuthenticationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BackchannelAuthenticationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BackchannelAuthenticationResponse' from JSON`,
  );
}
