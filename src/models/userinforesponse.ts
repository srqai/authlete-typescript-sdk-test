/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Pair,
  Pair$inboundSchema,
  Pair$Outbound,
  Pair$outboundSchema,
} from "./pair.js";
import {
  Property,
  Property$inboundSchema,
  Property$Outbound,
  Property$outboundSchema,
} from "./property.js";

/**
 * The next action that the authorization server implementation should take.
 */
export const UserinfoResponseAction = {
  InternalServerError: "INTERNAL_SERVER_ERROR",
  BadRequest: "BAD_REQUEST",
  Unauthorized: "UNAUTHORIZED",
  Forbidden: "FORBIDDEN",
  Ok: "OK",
} as const;
/**
 * The next action that the authorization server implementation should take.
 */
export type UserinfoResponseAction = ClosedEnum<typeof UserinfoResponseAction>;

export type UserinfoResponse = {
  /**
   * The code which represents the result of the API call.
   */
  resultCode?: string | undefined;
  /**
   * A short message which explains the result of the API call.
   */
  resultMessage?: string | undefined;
  /**
   * The next action that the authorization server implementation should take.
   */
  action?: UserinfoResponseAction | undefined;
  /**
   * The list of claims that the client application requests to be embedded in the ID token.
   *
   * @remarks
   */
  claims?: Array<string> | undefined;
  /**
   * The ID of the client application which is associated with the access token.
   *
   * @remarks
   */
  clientId?: number | undefined;
  /**
   * The client ID alias when the authorization request for the access token was made.
   *
   * @remarks
   */
  clientIdAlias?: string | undefined;
  /**
   * The flag which indicates whether the client ID alias was used when the authorization
   *
   * @remarks
   * request for the access token was made.
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The content that the authorization server implementation can use as the value of `WWW-Authenticate`
   *
   * @remarks
   * header on errors.
   */
  responseContent?: string | undefined;
  /**
   * The scopes covered by the access token.
   *
   * @remarks
   */
  scopes?: Array<string> | undefined;
  /**
   * The subject (= resource owner's ID).
   *
   * @remarks
   */
  subject?: string | undefined;
  /**
   * The access token that came along with the userinfo request.
   *
   * @remarks
   */
  token?: string | undefined;
  /**
   * The extra properties associated with the access token.
   *
   * @remarks
   */
  properties?: Array<Property> | undefined;
  /**
   * The value of the `userinfo` property in the `claims` request parameter or in the `claims` property in an authorization request object.
   *
   * @remarks
   *
   * A client application may request certain claims be embedded in an ID token or in a response from the userInfo endpoint.
   * There are several ways. Including the `claims` request parameter and including the `claims` property in a request object are such examples.
   * In both cases, the value of the `claims` parameter/property is JSON. Its format is described in [5.5. Requesting Claims using the "claims"
   * Request Parameter](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter).
   *
   * The following is an excerpt from the specification. You can find `userinfo` and `id_token` are top-level properties.
   *
   * ```json
   * {
   *   "userinfo":
   *   {
   *     "given_name": { "essential": true },
   *     "nickname": null,
   *     "email": { "essential": true },
   *     "email_verified": { "essential": true },
   *     "picture": null,
   *     "http://example.info/claims/groups": null
   *   },
   *   "id_token":
   *   {
   *     "auth_time": { "essential": true },
   *     "acr": { "values": [ "urn:mace:incommon:iap:silver" ] }
   *   }
   * }
   * ````
   *
   * The value of this property is the value of the `userinfo` property in JSON format.
   * For example, if the JSON above is included in an authorization request, this property holds JSON equivalent to the following.
   *
   * ```json
   * {
   *   "given_name": { "essential": true },
   *   "nickname": null,
   *   "email": { "essential": true },
   *   "email_verified": { "essential": true },
   *   "picture": null,
   *   "http://example.info/claims/groups": null
   * }
   * ```
   *
   * Note that if a request object is given and it contains the `claims` property and if the `claims` request parameter is also given,
   * the value of this property holds the former value.
   */
  userInfoClaims?: string | undefined;
  /**
   * The attributes of this service that the client application belongs to.
   *
   * @remarks
   */
  serviceAttributes?: Array<Pair> | undefined;
  /**
   * The attributes of the client.
   *
   * @remarks
   */
  clientAttributes?: Array<Pair> | undefined;
  /**
   * the claims that the user has consented for the client application
   *
   * @remarks
   * to know.
   */
  consentedClaims?: Array<string> | undefined;
  /**
   * Get names of claims that are requested indirectly by *"transformed
   *
   * @remarks
   * claims"*.
   * A client application can request *"transformed claims"* by adding
   * names of transformed claims in the `claims` request parameter.
   * The following is an example of the `claims` request parameter
   * that requests a predefined transformed claim named `18\_or\_over`
   * and a transformed claim named `nationality\_usa` to be embedded
   * in the response from the userinfo endpoint.
   * ```json
   * {
   * "transformed\_claims": {
   * "nationality\_usa": {
   * "claim": "nationalities",
   * "fn": [
   * [ "eq", "USA" ],
   * "any"
   * ]
   * }
   * },
   * "userinfo": {
   * "::18\_or\_over": null,
   * ":nationality\_usa": null
   * }
   * }
   * ```
   * The example above assumes that a transformed claim named `18\_or\_over`
   * is predefined by the authorization server like below.
   * ```json
   * {
   * "18\_or\_over": {
   * "claim": "birthdate",
   * "fn": [
   * "years\_ago",
   * [ "gte", 18 ]
   * ]
   * }
   * }
   * ```
   * In the example, the `nationalities` claim is requested indirectly
   * by the `nationality\_usa` transformed claim. Likewise, the
   * `birthdate` claim is requested indirectly by the `18\_or\_over`
   * transformed claim.
   * When the `claims` request parameter of an authorization request is
   * like the example above, this `requestedClaimsForTx` property will
   * hold the following value.
   * ```json
   * [ "birthdate", "nationalities" ]
   * ```
   * It is expected that the authorization server implementation prepares values
   * of the listed claims and passes them as the value of the `claimsForTx`
   * request parameter when it calls the `/api/auth/userinfo/issue` API. The following
   * is an example of the value of the `claimsForTx` request parameter.
   * ```json
   * {
   * "birthdate": "1970-01-23",
   * "nationalities": [ "DEU", "USA" ]
   * }
   * ```
   */
  requestedClaimsForTx?: Array<string> | undefined;
  /**
   * Names of verified claims that will be referenced when transformed claims are computed.
   *
   * @remarks
   */
  requestedVerifiedClaimsForTx?: Array<Array<string>> | undefined;
  /**
   * the value of the `transformed_claims` property in the `claims` request
   *
   * @remarks
   * parameter of an authorization request or in the `claims` property in a
   * request object.
   */
  transformedClaims?: string | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
  /**
   * The expected nonce value for DPoP proof JWT, which should be used
   *
   * @remarks
   * as the value of the `DPoP-Nonce` HTTP header.
   */
  dpopNonce?: string | undefined;
};

/** @internal */
export const UserinfoResponseAction$inboundSchema: z.ZodNativeEnum<
  typeof UserinfoResponseAction
> = z.nativeEnum(UserinfoResponseAction);

/** @internal */
export const UserinfoResponseAction$outboundSchema: z.ZodNativeEnum<
  typeof UserinfoResponseAction
> = UserinfoResponseAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserinfoResponseAction$ {
  /** @deprecated use `UserinfoResponseAction$inboundSchema` instead. */
  export const inboundSchema = UserinfoResponseAction$inboundSchema;
  /** @deprecated use `UserinfoResponseAction$outboundSchema` instead. */
  export const outboundSchema = UserinfoResponseAction$outboundSchema;
}

/** @internal */
export const UserinfoResponse$inboundSchema: z.ZodType<
  UserinfoResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: UserinfoResponseAction$inboundSchema.optional(),
  claims: z.array(z.string()).optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  responseContent: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  token: z.string().optional(),
  properties: z.array(Property$inboundSchema).optional(),
  userInfoClaims: z.string().optional(),
  serviceAttributes: z.array(Pair$inboundSchema).optional(),
  clientAttributes: z.array(Pair$inboundSchema).optional(),
  consentedClaims: z.array(z.string()).optional(),
  requestedClaimsForTx: z.array(z.string()).optional(),
  requestedVerifiedClaimsForTx: z.array(z.array(z.string())).optional(),
  transformedClaims: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  dpopNonce: z.string().optional(),
});

/** @internal */
export type UserinfoResponse$Outbound = {
  resultCode?: string | undefined;
  resultMessage?: string | undefined;
  action?: string | undefined;
  claims?: Array<string> | undefined;
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  responseContent?: string | undefined;
  scopes?: Array<string> | undefined;
  subject?: string | undefined;
  token?: string | undefined;
  properties?: Array<Property$Outbound> | undefined;
  userInfoClaims?: string | undefined;
  serviceAttributes?: Array<Pair$Outbound> | undefined;
  clientAttributes?: Array<Pair$Outbound> | undefined;
  consentedClaims?: Array<string> | undefined;
  requestedClaimsForTx?: Array<string> | undefined;
  requestedVerifiedClaimsForTx?: Array<Array<string>> | undefined;
  transformedClaims?: string | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
  dpopNonce?: string | undefined;
};

/** @internal */
export const UserinfoResponse$outboundSchema: z.ZodType<
  UserinfoResponse$Outbound,
  z.ZodTypeDef,
  UserinfoResponse
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: UserinfoResponseAction$outboundSchema.optional(),
  claims: z.array(z.string()).optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  responseContent: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  subject: z.string().optional(),
  token: z.string().optional(),
  properties: z.array(Property$outboundSchema).optional(),
  userInfoClaims: z.string().optional(),
  serviceAttributes: z.array(Pair$outboundSchema).optional(),
  clientAttributes: z.array(Pair$outboundSchema).optional(),
  consentedClaims: z.array(z.string()).optional(),
  requestedClaimsForTx: z.array(z.string()).optional(),
  requestedVerifiedClaimsForTx: z.array(z.array(z.string())).optional(),
  transformedClaims: z.string().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  dpopNonce: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserinfoResponse$ {
  /** @deprecated use `UserinfoResponse$inboundSchema` instead. */
  export const inboundSchema = UserinfoResponse$inboundSchema;
  /** @deprecated use `UserinfoResponse$outboundSchema` instead. */
  export const outboundSchema = UserinfoResponse$outboundSchema;
  /** @deprecated use `UserinfoResponse$Outbound` instead. */
  export type Outbound = UserinfoResponse$Outbound;
}

export function userinfoResponseToJSON(
  userinfoResponse: UserinfoResponse,
): string {
  return JSON.stringify(
    UserinfoResponse$outboundSchema.parse(userinfoResponse),
  );
}

export function userinfoResponseFromJSON(
  jsonString: string,
): SafeParseResult<UserinfoResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserinfoResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserinfoResponse' from JSON`,
  );
}
