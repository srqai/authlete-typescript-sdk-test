/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { AuthleteTestCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { AuthleteTestError } from "../models/errors/authletetesterror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Process Backchannel Authentication Request
 *
 * @remarks
 * This API parses request parameters of a [backchannel authentication request](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_request)
 * and returns necessary data for the authorization server implementation to process the backchannel
 * authentication request further.
 *
 * <br>
 * <details>
 * <summary>Description</summary>
 *
 * This API is supposed to be called from within the implementation of the [backchannel authentication
 * endpoint](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_backchannel_endpoint)
 * of the service. The endpoint implementation must extract the request parameters from the
 * backchannel authentication request from the client application and pass them as the value of parameters
 * request parameter for Authlete's `/backchannel/authentication` API.
 *
 * The value of parameters is the entire entity body (which is formatted in `application/x-www-form-urlencoded`)
 * of the request from the client application.
 *
 * The following code snippet is an example in JAX-RS showing how to extract request parameters from
 * the backchannel authentication request.
 *
 * ```java
 * @POST
 * @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
 * public Response post(String parameters)
 * {
 *     // 'parameters' is the entity body of the backchannel authentication request.
 *     ......
 * }
 * ```
 *
 * The endpoint implementation does not have to parse the request parameters from the client application
 * because Authlete's `/backchannel/authentication` API does it.
 *
 * The response from `/backchannel/authentication` API has various parameters. Among them, it is `action`
 * parameter that the authorization server implementation should check first because it denotes the
 * next action that the authorization server implementation should take. According to the value of
 * `action`, the service implementation must take the steps described below.
 *
 * **INTERNAL_SERVER_ERROR**
 *
 * When the value of `action` is `INTERNAL_SERVER_ERROR`, it means that the request from the authorization
 * server implementation was wrong or that an error occurred in Authlete.
 * In either case, from the viewpoint of the client application, it is an error on the server side.
 * Therefore, the service implementation should generate a response to the client application with
 * HTTP status of "500 Internal Server Error" and `application/json`.
 *
 * The value of `responseContent` is a JSON string which describes the error, so it can be used
 * as the entity body of the response.
 *
 * The following illustrates the response which the service implementation should generate and return
 * to the client application.
 *
 * ```
 * HTTP/1.1 500 Internal Server Error
 * Content-Type: application/json
 * Cache-Control: no-store
 * Pragma: no-cache
 *
 * {responseContent}
 * ```
 *
 * **BAD_REQUEST**
 *
 * When the value of `action` is `BAD_REQUEST`, it means that the request from the client application
 * is invalid.
 *
 * The authorization server implementation should generate a response to the client application with
 * "400 Bad Request" and `application/json`.
 *
 * The value of `responseContent` is a JSON string which describes the error, so it can be used as
 * the entity body of the response.
 *
 * The following illustrates the response which the service implementation should generate and return
 * to the client application.
 *
 * ```
 * HTTP/1.1 400 Bad Request
 * Content-Type: application/json
 * Cache-Control: no-store
 * Pragma: no-cache
 *
 * {responseContent}
 * ```
 *
 * **UNAUTHORIZED**
 *
 * When the value of `action` is `UNAUTHORIZED`, it means that client authentication of the backchannel
 * authentication request failed. Note that client authentication is always required at the backchannel
 * authentication endpoint. This implies that public clients are not allowed to use the backchannel
 * authentication endpoint.
 *
 * The authorization server implementation should generate a response to the client application with
 * "401 Unauthorized" and `application/json`.
 *
 * The value of `responseContent` is a JSON string which describes the error, so it can be used as
 * the entity body of the response.
 *
 * The following illustrates the response which the service implementation must generate and return
 * to the client application.
 *
 * ```
 * HTTP/1.1 401 Unauthorized
 * WWW-Authenticate: (challenge)
 * Content-Type: application/json
 * Cache-Control: no-store
 * Pragma: no-cache
 *
 * {responseContent}
 * ```
 *
 * **USER_IDENTIFICATION**
 *
 * When the value of `action` is `USER_IDENTIFICATION`, it means that the backchannel authentication
 * request from the client application is valid. The authorization server implementation has to follow
 * the steps below.
 *
 * [1] END-USER IDENTIFICATION
 *
 * The first step is to determine the subject (= unique identifier) of the end-user from whom the
 * client application wants to get authorization.
 *
 * According to the CIBA specification, a backchannel authentication request contains one (and only
 * one) of the `login_hint_token`, `id_token_hint` and `login_hint` request parameters as a hint
 * by which the authorization server identifies the subject of an end-user.<br>
 * The authorization server implementation can know which hint is included in the backchannel authentication
 * request by the `hintType` parameter. For example, when the value of the parameter `LOGIN_HINT`,
 * it means that the backchannel authentication request contains the `login_hint` request parameter
 * as a hint.<br>
 *
 * The value of the `hint` parameter is the value of the hint. For example, when the value of the
 * `hintType` parameter is `LOGIN_HINT`, The value of the `hint` parameter is the value of the `login_hint`
 * request parameter.<br>
 *
 * It is up to the authorization server implementation how to determine the subject of the end-user
 * from the hint. Only when the `id_token_hint` request parameter is used, authorization server
 * implementation can use the sub response parameter, which holds the value of the sub claim in the
 * `id_token_hint` request parameter.
 *
 * [2] END-USER IDENTIFICATION ERROR
 *
 * There are some cases where the authorization server implementation encounters an error during
 * the user identification process. In any error case, the service implementation has to return an
 * HTTP response with the error response parameter to the client application. The following is an
 * example of such error responses.
 *
 * ```
 * HTTP/1.1 400 Bad Request
 * Content-Type: application/json
 * Cache-Control: no-store
 * Pragma: no-cache
 *
 * { "error":"unknown_user_id" }
 * ```
 *
 * Authlete provides `/backchannel/authentication/fail` API that builds the response body (JSON)
 * of an error response. However, because it is easy to build an error response manually, you may
 * choose not to call the API. One good thing in using the API is that the API call can trigger
 * deletion of the ticket which has been issued from Authlete's `/backchannel/authentication` API.
 * If you don't call `/backchannel/authentication/fail` API, the ticket will continue to exist in
 * the database until it is cleaned up by the batch program after the ticket expires.<br>
 *
 * Possible error cases that the authorization server implementation itself has to handle are as
 * follows. Other error cases have already been covered by `/backchannel/authentication` API.
 *
 * - <u>`expired_login_hint_token`</u><br>
 *   The authorization server implementation detected that the hint presented by the `login_hint_token`
 *   request parameter has expired.
 *
 *   Note that the format of `login_hint_token` is not described in the CIBA Core spec at all and
 *   so there is no consensus on how to detect expiration of `login_hint_token`. Interpretation
 *   of `login_hint_token` is left to each authorization server implementation.
 *
 * - <u>`unknown_user_id`</u><br>
 *   The authorization server implementation could not determine the subject of the end-user by
 *   the presented hint.
 *
 * - <u>`unauthorized_client`</u><br>
 *   The authorization server implementation has custom rules to reject backchannel authentication
 *   requests from some particular clients and found that the client which has made the backchannel
 *   authentication request is one of the particular clients.
 *
 *   Note that `/backchannel/authentication` API does not return `action=USER_IDENTIFICATION` in
 *   cases where the client does not exist or client authentication has failed. Therefore, the
 *   authorization server implementation will never have to use the error code `unauthorized_client`
 *   unless the server has intentionally implemented custom rules to reject backchannel authentication
 *   requests based on clients.
 *
 * - <u>`missing_user_code`</u><br>
 *   The authorization server implementation has custom rules to require that a backchannel authentication
 *   request include a user code for some particular users and found that the user identified by
 *   the hint is one of the particular users.
 *
 *   Note that `/backchannel/authentication` API does not return `action=USER_IDENTIFICATION` when
 *   both the `backchannel_user_code_parameter_supported` metadata of the server and the
 *   `backchannel_user_code_parameter` metadata of the client are true and the backchannel authentication
 *   request does not include the user_code request parameter. In this case, `/backchannel/authentication`
 *   API returns action=BAD_REQUEST with JSON containing `"error":"missing_user_code"`. Therefore,
 *   the authorization server implementation will never have to use the error code `missing_user_code`
 *   unless the server has intentionally implemented custom rules to require a user code based
 *   on users even in the case where the `backchannel_user_code_parameter` metadata of the client
 *   which has made the backchannel authentication request is `false`.
 *
 * - <u>`invalid_user_code`</u><br>
 *   The authorization server implementation detected that the presented user code is invalid.
 *
 *   Note that the format of user_code is not described in the CIBA Core spec at all and so there
 *   is no consensus on how to judge whether a user code is valid or not. It is up to each authorization
 *   server implementation how to handle user codes.
 *
 * - <u>`invalid_binding_message`</u><br>
 *   The authorization server implementation detected that the presented binding message is invalid.
 *
 *   Note that the format of binding_message is not described in the CIBA Core spec at all and
 *   so there is no consensus on how to judge whether a binding message is valid or not. It is
 *   up to each authorization server implementation how to handle binding messages.
 *
 * - <u>`invalid_target`</u><br>
 *   The authorization server implementation rejects the requested target resources.
 *
 *   The error code invalid_target is from "Resource Indicators for OAuth 2.0". The specification
 *   defines the resource request parameter. By using the parameter, client applications can request
 *   target resources that should be bound to the access token being issued. If the authorization
 *   server wants to reject the request, call `/backchannel/authentication/fail` API with `INVALID_TARGET`.
 *
 * - <u>`access_denined`</u><br>
 *   The authorization server implementation has custom rules to reject backchannel authentication
 *   requests without asking the end-user and respond to the client as if the end-user had rejected
 *   the request in some particular cases and found that the backchannel authentication request
 *   is one of the particular cases.
 *
 *   The authorization server implementation will never have to use the error code `access_denied`
 *   at this timing unless the server has intentionally implemented custom rules to reject backchannel
 *   authentication requests without asking the end-user and respond to the client as if the end-user
 *   had rejected the request.
 *
 * [3] AUTH_REQ_ID ISSUE
 *
 * If the authorization server implementation has successfully determined the subject of the end-user,
 * the next action is to return an HTTP response to the client application which contains `auth_req_id`.
 *
 * Authlete provides `/backchannel/authentication/issue` API which generates a JSON containing `auth_req_id`,
 * so, your next action is (1) call the API, (2) receive the response from the API, (3) build a response
 * to the client application using the content of the API response, and (4) return the response to
 * the client application. See the description of `/backchannel/authentication/issue` API for details.
 *
 * [4] END-USER AUTHENTICATION AND AUTHORIZATION
 *
 * After sending a JSON containing `auth_req_id` back to the client application, the service implementation
 * starts to communicate with an authentication device of the end-user. It is assumed that end-user
 * authentication is performed on the authentication device and the end-user confirms the content of
 * the backchannel authentication request and grants authorization to the client application if everything
 * is okay. The authorization server implementation must be able to receive the result of the end-user
 * authentication and authorization from the authentication device.
 *
 * How to communicate with an authentication device and achieve end-user authentication and authorization
 * is up to each authorization server implementation, but the following request parameters of the backchannel
 * authentication request should be taken into consideration in any implementation.
 *
 * - <u>`acr_values`</u><br>
 *   A backchannel authentication request may contain an array of ACRs (Authentication Context Class
 *   References) in preference order. If multiple authentication devices are registered for the end-user,
 *   the authorization server implementation should take the ACRs into consideration when selecting
 *   the best authentication device.
 *
 * - <u>`scope`</u><br>
 *   A backchannel authentication request always contains a list of scopes. At least, `openid` is
 *   included in the list (otherwise `/backchannel/authentication` API returns `action=BAD_REQUEST`).
 *   It would be better to show the requested scopes to the end-user on the authentication device
 *   or somewhere appropriate.
 *
 *   If the scope request parameter contains `address`, `email`, `phone` and/or `profile`, they are
 *   interpreted as defined in "5.4. Requesting Claims using Scope Values of OpenID Connect Core 1.0".
 *   That is, they are expanded into a list of claim names. The claimNames parameter returns the expanded
 *   result.
 *
 * - <u>`binding_message`</u><br>
 *   A backchannel authentication request may contain a binding message. It is a human readable identifier
 *   or message intended to be displayed on both the consumption device (client application) and the
 *   authentication device.
 *
 * - <u>`user_code`</u><br>
 *   A backchannel authentication request may contain a user code. It is a secret code, such as password
 *   or pin, known only to the end-user but verifiable by the authorization server. The user code should
 *   be used to authorize sending a request to the authentication device.
 *
 * [5] END-USER AUTHENTICATION AND AUTHORIZATION COMPLETION
 *
 * After receiving the result of end-user authentication and authorization, the authorization server
 * implementation must call Authlete's `/backchannel/authentication/complete` API to tell Authlete
 * the result and pass necessary data so that Authlete can generate an ID token, an access token and
 * optionally a refresh token. See the description of the API for details.
 *
 * [6] CLIENT NOTIFICATION
 *
 * When the backchannel token delivery mode is either `ping` or `push`, the authorization server implementation
 * must send a notification to the pre-registered notification endpoint of the client after the end-user
 * authentication and authorization. In this case, the `action` parameter in a response from `/backchannel/authentication/complete`
 * API is `NOTIFICATION`. See the description of `/backchannel/authentication/complete` API for details.
 *
 * [7] TOKEN REQUEST
 *
 * When the backchannel token delivery mode is either `ping` or `poll`, the client application will make
 * a token request to the token endpoint to get an ID token, an access token and optionally a refresh
 * token.
 *
 * A token request that corresponds to a backchannel authentication request uses `urn:openid:params:grant-type:ciba`
 * as the value of the `grant_type` request parameter. Authlete's `/auth/token` API recognizes the
 * grant type automatically and behaves properly, so the existing token endpoint implementation does
 * not have to be changed to support CIBA.
 * </details>
 */
export function cibaProcessAuthentication(
  client: AuthleteTestCore,
  request: operations.BackchannelAuthenticationApiRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.BackchannelAuthenticationResponse,
    | errors.ResultError
    | AuthleteTestError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: AuthleteTestCore,
  request: operations.BackchannelAuthenticationApiRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.BackchannelAuthenticationResponse,
      | errors.ResultError
      | AuthleteTestError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.BackchannelAuthenticationApiRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.backchannel_authentication_request, {
    explode: true,
  });

  const pathParams = {
    serviceId: encodeSimple("serviceId", payload.serviceId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/api/{serviceId}/backchannel/authentication")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "backchannel_authentication_api",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.BackchannelAuthenticationResponse,
    | errors.ResultError
    | AuthleteTestError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, models.BackchannelAuthenticationResponse$inboundSchema),
    M.jsonErr([400, 401, 403], errors.ResultError$inboundSchema),
    M.jsonErr(500, errors.ResultError$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
