/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { AuthleteTestCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { AuthleteTestError } from "../models/errors/authletetesterror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Complete Backchannel Authentication
 *
 * @remarks
 * This API returns information about what action the authorization server should take after it receives
 * the result of end-user's decision about whether the end-user has approved or rejected a client application's
 * request on the authentication device.
 *
 * <br>
 * <details>
 * <summary>Description</summary>
 *
 * After the implementation of the backchannel authentication endpoint returns JSON containing an
 * `auth_req_id` to the client, the authorization server starts a background process that communicates
 * with the authentication device of the end-user. On the authentication device, end-user authentication
 * is performed and the end-user is asked whether they give authorization to the client or not. The
 * authorization server will receive the result of end-user authentication and authorization from
 * the authentication device.
 *
 * After the authorization server receives the result from the authentication device, or even in the
 * case where the server gave up receiving a response from the authentication device for some reasons,
 * the server should call the `/backchannel/authentication/complete` API to tell Authlete the result.
 *
 * When the end-user was authenticated and authorization was granted to the client by the end-user,
 * the authorization server should call the API with `result=AUTHORIZED`. In this successful case,
 * the `subject` request parameter is mandatory. If the token delivery mode is `push`, the API will generate
 * an access token, an ID token and optionally a refresh token. On the other hand, if the token delivery
 * mode is `poll` or `ping`, the API will just update the database record so that `/auth/token` API
 * can generate tokens later.
 *
 * When the authorization server received the decision of the end-user from the authentication device
 * and it indicates that the end-user has rejected to give authorization to the client, the authorization
 * server should call the API with `result=ACCESS_DENIED`. In this case, if the token delivery mode
 * is `push`, the API will generate an error response that contains the error response parameter and
 * optionally the `error_description` and error_uri response parameters (if the `errorDescription`
 * and `errorUri` request parameters have been given). On the other hand, if the token delivery mode
 * is `poll` or `ping`, the API will just update the database record so that `/auth/token` API can
 * generate an error response later. In any token delivery mode, the value of the error parameter will
 * become `access_denied`.
 *
 * When the authorization server could not get the result of end-user authentication and authorization
 * from the authentication device for some reasons, the authorization server should call the API with
 * `result=TRANSACTION_FAILED`. In this error case, the API will behave in the same way as in the case
 * of `ACCESS_DENIED`. The only difference is that `expired_token` is used as the value of the `error`
 * parameter.
 *
 * The response from `/backchannel/authentication/complete` API has various parameters. Among them,
 * it is `action` parameter that the authorization server implementation should check first because
 * it denotes the next action that the authorization server implementation should take. According to
 * the value of `action`, the service implementation must take the steps described below.
 *
 * **SERVER_ERROR**
 *
 * When the value of `action` is `SERVER_ERROR`, it means either (1) that the request from the authorization
 * server to Authlete was wrong, or (2) that an error occurred on Authlete side.
 *
 * When the backchannel token delivery mode is `ping` or `push`, `SERVER_ERROR` is used only when
 * an error is detected before the record of the ticket (which is included in the API call to `/backchannel/authentication/complete`)
 * is retrieved from the database successfully. If an error is detected after the record of the ticket
 * is retrieved from the database, `NOTIFICATION` is used instead of `SERVER_ERROR`.
 *
 * When the backchannel token delivery mode is `poll`, `SERVER_ERROR` is used regardless of whether
 * it is before or after the record of the ticket is retrieved from the database.
 *
 * **NO_ACTION**
 *
 * When the value of `action` is `NO_ACTION`, it means that the authorization server does not have
 * to take any immediate action.
 *
 * `NO_ACTION` is returned when the backchannel token delivery mode is `poll`. In this case, the client
 * will receive the final result at the token endpoint.
 *
 * **NOTIFICATION**
 *
 * When the value of `action` is `NOTIFICATION`, it means that the authorization server must send a
 * notification to the client notification endpoint.
 *
 * According to the CIBA Core specification, the notification is an HTTP POST request whose request
 * body is JSON and whose `Authorization` header contains the client notification token, which was
 * included in the backchannel authentication request as the value of the `client_notification_token`
 * request parameter, as a bearer token.
 *
 * When the backchannel token delivery mode is `ping`, the request body of the notification is JSON
 * which contains the `auth_req_id` property only. When the backchannel token delivery mode is `push`,
 * the request body will additionally contain an access token, an ID token and other properties. Note
 * that when the backchannel token delivery mode is `poll`, a notification does not have to be sent
 * to the client notification endpoint.
 *
 * In error cases, in the ping mode, however, the content of a notification is not different from the
 * content in successful cases. That is, the notification contains the `auth_req_id` property only.
 * The client will know the error when it accesses the token endpoint. On the other hand, in the
 * `push` mode, in error cases, the content of a notification will include the `error` property instead
 * of an access token and an ID token. The client will know the error by detecting that error is included
 * in the notification.
 *
 * In any case, the value of `responseContent` is JSON which can be used as the request body of the
 * notification.
 *
 * The client notification endpoint that the notification should be sent to the value of the `clientNotificationEndpoint`
 * parameter. Likewise, the client notification token that the notification should include as a bearer
 * token is the `clientNotificationToken` parameter. With these methods, the notification can be built
 * like the following.
 *
 * ```
 * POST {clientNotificationEndpoint} HTTP/1.1
 * HOST: {The host of clientNotificationEndpoint}
 * Authorization: Bearer {notificationToken}
 * Content-Type: application/json
 *
 * {responseContent}
 * ```
 * </details>
 */
export function cibaCompleteBackchannelAuthentication(
  client: AuthleteTestCore,
  request: operations.BackchannelAuthenticationCompleteApiRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.BackchannelAuthenticationCompleteResponse,
    | errors.ResultError
    | AuthleteTestError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: AuthleteTestCore,
  request: operations.BackchannelAuthenticationCompleteApiRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.BackchannelAuthenticationCompleteResponse,
      | errors.ResultError
      | AuthleteTestError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.BackchannelAuthenticationCompleteApiRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON(
    "body",
    payload.backchannel_authentication_complete_request,
    { explode: true },
  );

  const pathParams = {
    serviceId: encodeSimple("serviceId", payload.serviceId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/api/{serviceId}/backchannel/authentication/complete",
  )(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "backchannel_authentication_complete_api",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.BackchannelAuthenticationCompleteResponse,
    | errors.ResultError
    | AuthleteTestError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, models.BackchannelAuthenticationCompleteResponse$inboundSchema),
    M.jsonErr([400, 401, 403], errors.ResultError$inboundSchema),
    M.jsonErr(500, errors.ResultError$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
